<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />

<script src="https://unpkg.com/konva@8.4.2/konva.min.js"></script>
<script src="https://unpkg.com/vue@3"></script>

<title>diagram-maker - Draw Markov chain</title>
<style>

#app {
	margin: 0;
	padding: 0;
	overflow: hidden;
	background-color: white;
}

#container {
	margin: 4px;
	border: 1px solid black;
}

</style>
</head>
<body>

<div id="app">
	<button @click="handleAddVertex">Add Vertex</button>
	<button @click="handleAddEdge">Add Edge</button>
	<button @click="handleAddText">Add Text</button>
	<button @click="handleCopyObject" title="Create duplicate of selected object">Copy Object</button>
	<button @click="handleToggleControlObjects" title="Toggle Control Objects">Toggle Control Objects</button>
	<div ref="konvaContainerElement"></div>
</div>

<script>

const app = Vue.createApp({
	data() {
		return ({
			konvaStage: null,
			konvaLayer: null,
		});
	},
	methods: {
		initKonva() {
			let konvaContainerWidth = window.innerWidth;
			let konvaContainerHeight = window.innerHeight;
			let konvaContainerElement = this.$refs.konvaContainerElement;
			let stage = new Konva.Stage({
				container: konvaContainerElement,
				width: konvaContainerWidth,
				height: konvaContainerHeight,
			});
			let layer = new Konva.Layer();
			stage.add(layer);
			this.konvaStage = stage;
			this.konvaLayer = layer;
		},
		handleAddVertex() {
			var vertex = new Konva.Circle({
				radius: 40,
				fill: null,
				stroke: 'black',
				strokeWidth: 1,
				draggable: true,
			});
			this.konvaLayer.add(vertex);
		},
		handleAddEdge() {
			var stage = this.konvaStage;
			var layer = this.konvaLayer;
			function buildAnchor(x, y) {
				var anchor = new Konva.Circle({
					x: x,
					y: y,
					radius: 5,
					stroke: 'blue',
					fill: null,
					name: 'bezierControlObject',
					strokeWidth: 1,
					draggable: true,
				});
				layer.add(anchor);
				// add hover styling
				anchor.on('mouseover', function () {
					document.body.style.cursor = 'pointer';
					this.strokeWidth(4);
				});
				anchor.on('mouseout', function () {
					document.body.style.cursor = 'default';
					this.strokeWidth(2);
				});
				anchor.on('dragmove', function () {
					updateDottedLines();
				});
				return anchor;
			}
			function updateDottedLines() {
				var b = bezier;
				var bezierLinePath = layer.findOne('#bezierLinePath');
				bezierLinePath.points([
					b.start.x(),
					b.start.y(),
					b.control1.x(),
					b.control1.y(),
					b.control2.x(),
					b.control2.y(),
					b.end.x(),
					b.end.y(),
				]);
			}
			var bezierLine = new Konva.Shape({
				stroke: 'black',
				strokeWidth: 1,
				pointerLength: 10,
				pointerWidth: 10,
				sceneFunc: (ctx, shape) => {
					ctx.beginPath();
					ctx.moveTo(bezier.start.x(), bezier.start.y());
					ctx.bezierCurveTo(
						bezier.control1.x(),
						bezier.control1.y(),
						bezier.control2.x(),
						bezier.control2.y(),
						bezier.end.x(),
						bezier.end.y()
					);
					ctx.fillStrokeShape(shape);
					// draw arrow pointer here:
					var PI2 = Math.PI * 2;
  		  	var dx = bezier.end.x() - bezier.control2.x();
  		  	var dy = bezier.end.y() - bezier.control2.y();
  		  	//var dy = points[3] - points[1];
  		  	var radians = (Math.atan2(dy, dx) + PI2) % PI2;
  		  	var length = shape.getAttr('pointerLength');
  		  	var width = shape.getAttr('pointerWidth');
  		  	// draw pointer
  		  	ctx.save();
  		  	ctx.beginPath();
  		  	ctx.translate(bezier.end.x(), bezier.end.y());
  		  	ctx.rotate(radians);
  		  	ctx.moveTo(0, 0);
  		  	ctx.lineTo(-length, width / 2);
  		  	ctx.moveTo(0, 0);
  		  	ctx.lineTo(-length, -width / 2);
  		  	ctx.restore();
  		  	ctx.fillStrokeShape(shape);
				},
			});
			layer.add(bezierLine);
			var bezierLinePath = new Konva.Line({
				dash: [10, 10, 0, 10],
				strokeWidth: 1,
				stroke: 'blue',
				lineCap: 'round',
				id: 'bezierLinePath',
				name: 'bezierControlObject',
				opacity: 0.95,
				points: [0, 0],
			});
			layer.add(bezierLinePath);
			var bezier = {
				start: buildAnchor(280, 20),
				control1: buildAnchor(530, 40),
				control2: buildAnchor(480, 150),
				end: buildAnchor(300, 150),
			};
			updateDottedLines();
		});
		return anchor;
	}
	//var stage = new Konva.Stage({
	//  container: 'container',
	//  width: width,
	//  height: height,
	//});
	//var layer = new Konva.Layer();
	//stage.add(layer);
	// function to update line points from anchors
	function updateDottedLines() {
		//var q = quad;
		var b = bezier;
		//var quadLinePath = layer.findOne('#quadLinePath');
		var bezierLinePath = layer.findOne('#bezierLinePath');
		//quadLinePath.points([
		//	q.start.x(),
		//	q.start.y(),
		//	q.control.x(),
		//	q.control.y(),
		//	q.end.x(),
		//	q.end.y(),
		//]);
		bezierLinePath.points([
			b.start.x(),
			b.start.y(),
			b.control1.x(),
			b.control1.y(),
			b.control2.x(),
			b.control2.y(),
			b.end.x(),
			b.end.y(),
		]);
	}
	// we will use custom shape for curve
	//var quadraticLine = new Konva.Shape({
	//	stroke: 'red',
	//	strokeWidth: 4,
	//	sceneFunc: (ctx, shape) => {
	//		ctx.beginPath();
	//		ctx.moveTo(quad.start.x(), quad.start.y());
	//		ctx.quadraticCurveTo(
	//			quad.control.x(),
	//			quad.control.y(),
	//			quad.end.x(),
	//			quad.end.y()
	//		);
	//		ctx.fillStrokeShape(shape);
	//	},
	//});
	//layer.add(quadraticLine);
	// we will use custom shape for curve
	var bezierLine = new Konva.Shape({
		stroke: 'black',
		strokeWidth: 1,
		pointerLength: 10,
		pointerWidth: 10,
		sceneFunc: (ctx, shape) => {
			ctx.beginPath();
			ctx.moveTo(bezier.start.x(), bezier.start.y());
			ctx.bezierCurveTo(
				bezier.control1.x(),
				bezier.control1.y(),
				bezier.control2.x(),
				bezier.control2.y(),
				bezier.end.x(),
				bezier.end.y()
			);
			ctx.fillStrokeShape(shape);
			// draw arrow pointer here:
			var PI2 = Math.PI * 2;
    	var dx = bezier.end.x() - bezier.control2.x();
    	var dy = bezier.end.y() - bezier.control2.y();
    	//var dy = points[3] - points[1];
    	var radians = (Math.atan2(dy, dx) + PI2) % PI2;
    	var length = shape.getAttr('pointerLength');
    	var width = shape.getAttr('pointerWidth');
    	// draw pointer
    	ctx.save();
    	ctx.beginPath();
    	ctx.translate(bezier.end.x(), bezier.end.y());
    	ctx.rotate(radians);
    	ctx.moveTo(0, 0);
    	ctx.lineTo(-length, width / 2);
    	ctx.moveTo(0, 0);
    	ctx.lineTo(-length, -width / 2);
    	ctx.restore();
    	ctx.fillStrokeShape(shape);
		},
		handleAddText() { },     // TODO
		handleCopyObject() { },  // TODO
		handleToggleControlObjects() {
			var controlObjects = this.konvaStage.find('.bezierControlObject');
			if (this.isControlObjectsVisible) {
				controlObjects.forEach(function (shape) {
					shape.hide();
				});
			} else {
				controlObjects.forEach(function (shape) {
					shape.show();
				});
			}
			this.isControlObjectsVisible = !this.isControlObjectsVisible;
		}
	},
	mounted() {
		this.initKonva();
	}
});

app.mount('#app');
</script>
</body>
</html>
